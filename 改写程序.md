## 改写TxInput和TxOutput
```go

type TXInput struct {
	TXID  []byte //交易id
	Index int64  //ouput的索引
	//Address string //解锁脚本，先用地址来模拟
	Signature []byte //交易签名
	Pubkey    []byte //公钥本身，不是公钥哈希
}

type TXOutput struct {
	Value float64 //转账金额
	//Address string  //锁定脚本
	PubKeyHash []byte //公钥哈希，不是公钥本身
}
```

## Lock方法
```go
func (output *TXOutput) Lock(address string) {
	//address ->public key hash
	decodeInfo := base58.Decode(address)
	pubKeyHash := decodeInfo[1 : len(decodeInfo)-4]
	output.PubKeyHash = pubKeyHash
}
```
## NewTXOutput方法
```go
func NewTXOutput(value float64, address string) TXOutput {
	output := TXOutput{Value: value}
	output.Lock(address)
	return output
}
```

## 改写coinbaseTx
``` go 

//挖矿奖励
const reward = 12.5

//把挖矿的人传递进来，因为有奖励
func NewCoinbaseTx(miner string, data string) *Transaction {

	inputs := []TXInput{TXInput{nil, -1, nil, []byte(data)}}
	//outputs := []TXOutput{TXOutput{12.5, miner}}

	output := NewTXOutput(reward, miner)
	outputs := []TXOutput{output}

	tx := Transaction{nil, inputs, outputs}
	tx.SetTXID()

	return &tx
}
```
## 改写NewTransaction函数
```go
func NewTransaction(from, to string, amount float64, bc *BlockChain) *Transaction {
	//1.打开钱包
	ws := NewWallets()

	wallet := ws.WalletsMap[from]

	if wallet == nil {
		fmt.Printf("%s的私钥不存在，交易创建失败!\n")
		return nil
	}

	//2.获取公钥私钥
	//privateKey:=wallet.PrivateKey //目前用不到，步骤三签名时使用
	publicKey := wallet.PublicKey

	publicKeyHash := hashPubkHash(from)

	utxos := make(map[string][]int64)
	var resValue float64
	//遍历账本，找到属于付款人的合适的金额，把这个outputs找到
	utxos, resValue = bc.FindNeedUtxos(publicKeyHash, amount)

	//如果找到钱不足以转账，创建交易失败
	if resValue < amount {
		fmt.Printf("余额不足，交易失败!\n")
		return nil
	}

	var inputs []TXInput
	var outputs []TXOutput

	//将outputs转成inputs
	for txid, indexes := range utxos {
		for _, i := range indexes {
			input := TXInput{[]byte(txid), i, nil, publicKey}
			inputs = append(inputs, input)

		}
	}
	//创建输出，创建一个属于收款人的output
	//output := TXOutput{amount, to}
	output := NewTXOutput(amount, to)
	outputs = append(outputs, output)

	//如果有找零，创建属于付款人output
	if resValue > amount {
		//output1 := TXOutput{resValue - amount, from}
		output1 := NewTXOutput(resValue-amount, from)
		outputs = append(outputs, output1)
	}
	//创建交易
	tx := Transaction{nil, inputs, outputs}
	//设置交易id
	tx.SetTXID()
	//返回交易结构
	return &tx

}
```
## 改写GetAddress
```go

func (w *WalletKeyPair) GetAddress() string {
	publicHash := HashPubKey(w.PublicKey)

	version := 0x00

	//21字节数据
	payload := append([]byte{byte(version)}, publicHash...)

	checksum := CheckSum(payload)

	//25字节数据
	payload = append(payload, checksum...)
	address := base58.Encode(payload)

	return address

}

func HashPubKey(pubKey []byte) []byte {
	hash := sha256.Sum256(pubKey)

	//创建一个hash160对象
	//想hash160中write数据
	//做hash运算
	rip160Hasher := ripemd160.New()
	_, err := rip160Hasher.Write(hash[:])
	if err != nil {
		log.Panic(err)
	}

	//Sum函数会把我们的结果与Sum参数append到一起，然后返回，我们传入nil，放置数据污染
	publicHash := rip160Hasher.Sum(nil)

	return publicHash
}

func CheckSum(payload []byte) []byte {
	first := sha256.Sum256(payload)
	second := sha256.Sum256(first[:])

	//4字节校验码
	checksum := second[0:4]

	return checksum
}
```
