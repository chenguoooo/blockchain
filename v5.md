## ecdsaTest.go
```go
import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"fmt"
	"math/big"
	"os"
)

func main() {
	//1.创建私钥
	//2.创建公钥
	//3.私钥对数据进行签名
	//4.使用数据，签名，公钥进行校验

	curve := elliptic.P256()
	privateKey, err := ecdsa.GenerateKey(curve, rand.Reader)

	if err != nil {
		os.Exit(1)
	}
	pubKey := privateKey.PublicKey

	data := "hello"

	dataHash := sha256.Sum256([]byte(data))

	r, s, err := ecdsa.Sign(rand.Reader, privateKey, dataHash[:])

	//一般传输过程中，会把r，s拼成字节流再传输
	fmt.Printf("r:%x,len(r):%d\n", r.Bytes(), len(r.Bytes()))
	fmt.Printf("s:%x,len(s):%d\n", s.Bytes(), len(s.Bytes()))
	signagure := append(r.Bytes(), s.Bytes()...)

	if err != nil {
		os.Exit(1)
	}

	//传输中...:数据，签名，公钥

	//在接收端从中把r和s切出来
	var r1 big.Int
	var s1 big.Int
	r1Data := signagure[:len(signagure)/2]
	s1Data := signagure[len(signagure)/2:]

	r1.SetBytes(r1Data)
	s1.SetBytes(s1Data)
	fmt.Printf("r1:%x,len(r1):%d\n", r1.Bytes(), len(r1.Bytes()))
	fmt.Printf("s1:%x,len(s1):%d\n", s1.Bytes(), len(s1.Bytes()))

	res := ecdsa.Verify(&pubKey, dataHash[:], &r1, &s1)

	fmt.Printf("res:%v\n", res)

}
```

## 定义钱包结构
```go
package main

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"log"
)

type WalletKeyPair struct {
	PrivateKey *ecdsa.PrivateKey

	//type PublicKey struct {
	//	elliptic.Curve
	//	X, Y *big.Int
	//}

	//将公钥的X,Y进行字节流拼接后传输
	PublicKey []byte
}

func NewWalletKeyPair() *WalletKeyPair {
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)

	if err != nil {
		log.Panic(err)
	}

	publicKeyRaw := privateKey.PublicKey
	publicKey := append(publicKeyRaw.X.Bytes(), publicKeyRaw.Y.Bytes()...)
	return &WalletKeyPair{PrivateKey: privateKey, PublicKey: publicKey}
}
```

## 根据公钥获取地址
```go

func NewWalletKeyPair() *WalletKeyPair {
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)

	if err != nil {
		log.Panic(err)
	}

	publicKeyRaw := privateKey.PublicKey
	publicKey := append(publicKeyRaw.X.Bytes(), publicKeyRaw.Y.Bytes()...)
	return &WalletKeyPair{PrivateKey: privateKey, PublicKey: publicKey}
}

func (w *WalletKeyPair) GetAddress() string {
	hash := sha256.Sum256(w.PublicKey)

	//创建一个hash160对象
	//想hash160中write数据
	//做hash运算
	rip160Hasher := ripemd160.New()
	_, err := rip160Hasher.Write(hash[:])
	if err != nil {
		log.Panic(err)
	}

	//Sum函数会把我们的结果与Sum参数append到一起，然后返回，我们传入nil，放置数据污染
	publicHash := rip160Hasher.Sum(nil)
	version := 0x00

	//21字节数据
	payload := append([]byte{byte(version)}, publicHash...)

	first := sha256.Sum256(payload)
	second := sha256.Sum256(first[:])

	//4字节校验码
	checksum := second[0:4]

	//25字节数据
	payload = append(payload, checksum...)
	address := base58.Encode(payload)

	return address

}
```

## 获取钱包实例
```go
//创建wallets，返回wallets实例
func NewWallets() *Wallets {
	var ws Wallets

	ws.WalletsMap = make(map[string]*WalletKeyPair)
	//把所有的钱包从本地加载出来
	//TODO

	//把实例返回
	return &ws
}
```

## 创建新钱包
```go

func (ws *Wallets) CreateWallet() string {
	//调用Newwalletkeypair
	wallet := NewWalletKeyPair()
	//将返回的Newwalletkeypair添加到walletmap中
	address := wallet.GetAddress()

	ws.WalletsMap[address] = wallet
	//
	//var wsLocal Wallets
	//wsLocal.WalletsMap[address] = wallet
	//ws.WalletsMap = wsLocal.WalletsMap
	//保存到本地文件
	//TODO

	return address
}
```
## 调用
```go

func (cli *CLI) CreateWallet() {

	ws := NewWallets()
	address := ws.CreateWallet()

	fmt.Printf("新的钱包地址为：%s\n", address)
}
```

## 保存钱包到文件
gob.Register:对于结构中的interface类型，需要明确类型
ioutil.writefile实现文件写入
```go

//保存钱包到文件
func (ws *Wallets) SaveToFile() bool {

	var buffer bytes.Buffer
	//将接口类型明确注册一下，否则gob编码失败
	gob.Register(elliptic.P256())
	encoder := gob.NewEncoder(&buffer)
	err := encoder.Encode(ws)
	if err != nil {
		fmt.Printf("钱包序列化失败,err:%v\n", err)
	}
	content := buffer.Bytes()

	//func WriteFile(filename string, data []byte, perm os.FileMode) error {
	err = ioutil.WriteFile(WalletName, content, 0600)
	if err != nil {
		fmt.Printf("钱包创建失败！\n")
		return false
	}

	return true

}
```

## 加载钱包
```go

func (ws *Wallets) LoadFromFile() bool {
	//判断文件是否存在
	if !IsFileExist(WalletName) {
		fmt.Printf("钱包文件不存在，准备创建！\n")
		return true
	}

	//读取文件

	content, err := ioutil.ReadFile(WalletName)

	if err != nil {
		return false
	}
	gob.Register(elliptic.P256())
	//gob解码
	decoder := gob.NewDecoder(bytes.NewReader(content))

	var wallets Wallets
	err = decoder.Decode(&wallets)

	if err != nil {
		fmt.Printf("err:%v\n", err)
		return false
	}
	//赋值给ws
	ws.WalletsMap = wallets.WalletsMap
	return true

}
```

## 遍历钱包，打印地址
```go

func (ws *Wallets) ListAddress() []string {
	//遍历ws.WalletsMap结构返回key即可
	var addresses []string
	for address, _ := range ws.WalletsMap {
		addresses = append(addresses, address)
	}
	return addresses
}
```
## 在commands.go中调用
```go
func (cli *CLI) ListAddresses() {
	ws := NewWallets()

	addresses := ws.ListAddress()
	for _, address := range addresses {
		fmt.Printf("address:%s\n", address)
	}
}
```
